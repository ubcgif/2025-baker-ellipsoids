# file for doing rotations between global and local coordinate systems.#definitions for triaxial# alpha = azimuth of plunge of major axis (a) (clockwise from +x)# beta = plunge of major axis (angle between major axis and horizonal)# gamma = angle between upwards dorected intermediate axis and vertical plane containing major axis# posiitve clockwise (?)import numpy as np#from .utils import get_coords_and_maskimport verde as vddef structural_angles_to_abg(): # we can decide if this is needed    ...def get_body_unit_vectors(alpha, beta, gamma): # in degrees    """    Creates the unit vectors of the body (local) coordinate axis from the     global coordinate axis.        parameters    ----------    alpha (float, 0<=alpha<=360) = azimuth of plunge of major axis (a) (clockwise from +x)    beta (float, 0<=beta<=90) = plunge of major axis (angle between major axis and horizonal)    gamma (float, -90<=gamma<=90) =  angle between upwards directed intermediate                                     axis and vertical plane containing major axis                                        returns    -------     # not sure how is best to lay this out     V: v1 [l1, m1, n1] (vector)        v2 [l2, m2, n2] (vector)        v3 [l3, m3, n3] (vector) :                   """        # check inputs are valid     if not (0<=alpha<=360):        raise ValueError("Invalid value for alpha."                         f"Expected 0<=alpha<=360, got {alpha}.")            if not (0<=beta<=90):        raise ValueError("Invalid value for beta."                         f"Expected 0<=beta<=90, got {beta}.")            if not (-90<=gamma<=90):        raise ValueError("Invalid value for gamma."                         f"Expected -90<=gamma<=90, got {gamma}.")        # convert to radians    alpha = np.radians(alpha)    beta = np.radians(beta)    gamma = np.radians(gamma)        v1 = [l1, m1, n1] = (-np.cos(alpha) * np.cos(beta),                         -np.sin(alpha) * np.cos(beta),                         -np.sin(beta))        v2 = [l2, m2, n2] = (np.cos(alpha) * np.cos(gamma) * np.sin(beta) + np.sin(alpha) * np.sin(gamma),                         np.sin(alpha) * np.cos(gamma) * np.sin(beta) - np.cos(alpha) * np.sin(gamma),                         - np.cos(gamma) * np.cos(beta))        v3 = [l3, m3, n3] = (np.sin(alpha) * np.cos(gamma) - np.cos(alpha) * np.sin(gamma) * np.sin(beta),                         -np.cos(alpha) * np.cos(gamma) - np.sin(alpha) * np.sin(beta) * np.sin(gamma),                         np.sin(gamma) * np.cos(beta))        V = [v1, v2, v3]    #L = (l1, l2, l3)    #M = (m1, m2, m3)    #N = (n1, n2, n3)        return V#V = get_body_unit_vectors(90, 40, 10)#print(V)def global_to_local(alpha, beta, gamma, northing, easting, extra_coords, depth):        """    Conversion of a point from global coordinates, which we refer to as     Northing, easting, height, to local coordinates which we refer to as x, y, z.        Parameters    ----------    V (matrix): Body axis rotation matrix in terms of alpha, beta, gamma.    northing, easting, extra_coords (arrays): observation plane to be converted into     local coordinates. NOTE: 'extra_coords' as given in vd.grid_coordinates refers    to the height of the plane above the surface.     depth (float): the depth of the body below the surface.        Returns    -------    x, y, z (arrays, floats): Observatin points to convert from global to local        NOTES:            Currently only translates body below surface, will need to translate body     from an origin point which also varies in northing/easting.        """    # get unit rotations (V)    V = get_body_unit_vectors(alpha, beta, gamma)        # create arrays to hold local coords    x = np.ones(northing.shape)    y = np.ones(northing.shape)    z = np.ones(northing.shape)    local_coords = [x, y, z]            for i in range(len(local_coords)):        local_coords[i] = northing * V[i][0] + easting * V[i][1] \            - (depth - extra_coords)*V[i][2]                return local_coordsnorthing, easting, extra_coords = vd.grid_coordinates(region = (-20, 20, -20, 20), spacing=1, extra_coords=1)local_coords = global_to_local(80, 40, 10, northing, easting, extra_coords, 10)print(local_coords[0])